{"version":3,"sources":["../src/coders/bigint.ts","../src/coders/vlq.ts","../src/coders/zigZag.ts","../src/coders/sigmaByteReader.ts","../src/coders/sigmaByteWriter.ts","../src/types/base.ts","../src/types/primitives.ts","../src/types/monomorphics.ts","../src/types/descriptors.ts","../src/types/generics.ts","../src/types/constructors.ts","../src/serializers/dataSerializer.ts","../src/serializers/typeSerializer.ts","../src/sigmaConstant.ts","../src/serializers/boxSerializer.ts","../src/serializers/transactionSerializer.ts"],"names":["hex","_0n","first","_127n","_7n","_128n","ensureBigInt","_1n","_63n","isEmpty","ensureBytes","blake2b256","assert","last","isDefined","some","isUndefined","byteSizeOf"],"mappings":"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","file":"index.js","sourcesContent":["import { _0n, first } from \"@fleet-sdk/common\";\n\n/**\n * Converts a hex string to bigint.\n * @param hex The hex string to be converted.\n * @returns The bigint value represented by the hex string.\n */\nexport function hexToBigInt(hex: string): bigint {\n  // https://coolaj86.com/articles/convert-hex-to-decimal-with-js-bigints/\n  const value = BigInt(hex.length % 2 ? `0x0${hex}` : `0x${hex}`);\n  const highByte = Number.parseInt(hex.slice(0, 2), 16);\n  if (0x80 & highByte) return -negateAndMask(value);\n\n  return value;\n}\n\n/**\n * Serializes a `BigInt` to a hex string\n * @param value The bigint value to be serialized\n * @returns Hex representation for the provided `number`.\n */\nexport function bigIntToHex(value: bigint): string {\n  // implementation inspired on\n  // https://coolaj86.com/articles/convert-decimal-to-hex-with-js-bigints/\n  const positive = value >= _0n;\n  let hex = (positive ? value : negateAndMask(value)).toString(16);\n  if (hex.length % 2) hex = `0${hex}`;\n\n  if (positive && 0x80 & Number.parseInt(hex.slice(0, 2), 16)) {\n    return `00${hex}`;\n  }\n\n  return hex;\n}\n\n/**\n * Returns the two’s complement of a bigint value.\n * @param value The bigint value to negate.\n * @returns The two’s complement of `number` as a bigint.\n */\nexport function negateAndMask(value: bigint): bigint {\n  let val = value;\n  const negative = val < _0n;\n  if (negative) val = -val; // turn into a positive number\n\n  const bits = val.toString(2);\n  let len = bits.length; // convert to binary\n  const mod = len % 8;\n\n  if (mod > 0) {\n    len += 8 - mod;\n  } else if (negative && first(bits) === \"1\" && bits.indexOf(\"1\", 1) !== -1) {\n    len += 8;\n  }\n\n  const mask = (1n << BigInt(len)) - 1n; // create a mask\n  return (~val & mask) + 1n; // invert bits, mask it, and add one\n}\n","import { _0n, _127n, _128n, _7n, ensureBigInt } from \"@fleet-sdk/common\";\nimport type { SigmaByteReader } from \"./sigmaByteReader\";\nimport type { SigmaByteWriter } from \"./sigmaByteWriter\";\n\n/**\n * A **variable-length quantity (VLQ)** is a universal code that uses an arbitrary number\n * of binary octets (eight-bit bytes) to represent an arbitrarily large integer. A VLQ\n * is essentially a base-128 representation of an unsigned integer with the addition of\n * the eighth bit to mark continuation of bytes. VLQ is identical to LEB128 except in\n * endianness. See the example below.\n */\n\n/**\n * Write an unsigned integer value as VLQ to a `SigmaByteWriter`.\n * @param value: Integer value\n * @param writer: Sigma writer\n * @returns Sigma writer passed as function argument.\n */\nexport function writeVLQ(writer: SigmaByteWriter, value: number): SigmaByteWriter {\n  // source: https://stackoverflow.com/a/3564685\n  if (value === 0) return writer.write(0);\n  if (value < 0) {\n    throw new RangeError(\"Variable Length Quantity not supported for negative numbers.\");\n  }\n\n  let val = value;\n  do {\n    let lower7bits = val & 0x7f;\n    val >>= 7;\n    if (val > 0) lower7bits |= 0x80;\n    writer.write(lower7bits);\n  } while (val > 0);\n\n  return writer;\n}\n\n/**\n * Decode VLQ bytes to an unsigned integer value\n * @param reader VLQ bytes\n * @returns Unsigned integer value\n */\nexport function readVLQ(reader: SigmaByteReader): number {\n  if (reader.isEmpty) {\n    return 0;\n  }\n\n  let value = 0;\n  let shift = 0;\n  let lower7bits = 0;\n\n  do {\n    lower7bits = reader.readByte();\n    value |= (lower7bits & 0x7f) << shift;\n    shift += 7;\n  } while ((lower7bits & 0x80) !== 0);\n\n  return value;\n}\n\n/**\n * Write an unsigned integer value as VLQ to a `SigmaByteWriter`.\n * @param value: Big integer value\n * @param writer: Sigma writer\n * @returns Sigma writer passed as function argument.\n */\nexport function writeBigVLQ(writer: SigmaByteWriter, value: bigint): SigmaByteWriter {\n  // source: https://stackoverflow.com/a/3564685\n\n  if (value === _0n) return writer.write(0);\n  if (value < _0n) {\n    throw new RangeError(\"Variable Length Quantity not supported for negative numbers\");\n  }\n\n  let val = value;\n  do {\n    let lower7bits = Number(val & _127n);\n    val >>= _7n;\n    if (val > 0) lower7bits |= 0x80;\n    writer.write(lower7bits);\n  } while (val > 0);\n\n  return writer;\n}\n\n/**\n * Decode VLQ bytes to an unsigned big integer value\n * @param reader VLQ bytes\n * @returns Unsigned integer value\n */\nexport function readBigVLQ(reader: SigmaByteReader): bigint {\n  if (reader.isEmpty) return _0n;\n\n  let value = _0n;\n  let shift = _0n;\n  let lower7bits = _0n;\n\n  do {\n    lower7bits = BigInt(reader.readByte());\n    value |= (lower7bits & _127n) << shift;\n    shift += _7n;\n  } while ((lower7bits & _128n) !== _0n);\n\n  return value;\n}\n\n/**\n * Estimates the byte size of a given unsigned integer.\n * @param value: the value to be evaluated.\n * @returns the byte size of the value.\n */\nexport function estimateVLQSize(value: number | bigint | string): number {\n  let size = 0;\n  let val = value;\n  if (typeof val === \"number\") {\n    do {\n      size++;\n      val = Math.floor(val / 128);\n    } while (val > 0);\n\n    return size;\n  }\n\n  val = ensureBigInt(val);\n  do {\n    size++;\n    val /= _128n;\n  } while (val > _0n);\n\n  return size;\n}\n","import { _1n, _63n } from \"@fleet-sdk/common\";\n\n/**\n * ZigZag encoding maps signed integers to unsigned integers so that numbers\n * with a small absolute value (for instance, -1) have a small variant encoded\n * value too. It does this in a way that \"zig-zags\" back and forth through the\n * positive and negative integers, so that -1 is encoded as 1, 1 is encoded as 2,\n * -2 is encoded as 3, and so on.\n * @see https://developers.google.com/protocol-buffers/docs/encoding#types\n */\n\n/**\n * Encode a signed integer.\n * @param input Signed integer\n * @returns ZigZag-encoded value\n */\nexport function zigZagEncode(input: number): number {\n  return (input << 1) ^ (input >> 63);\n}\n\n/**\n * Decode a ZigZag-encoded value.\n * @param input ZigZag-encoded value\n * @returns Signed integer\n */\nexport function zigZagDecode(input: number): number {\n  return (input >> 1) ^ -(input & 1);\n}\n\n/**\n * Encode a signed big integer.\n * @param input Signed big integer\n * @returns ZigZag-encoded value\n */\nexport function zigZagEncodeBigInt(input: bigint): bigint {\n  return (input << _1n) ^ (input >> _63n);\n}\n\n/**\n * Decode a ZigZag-encoded value.\n * @param input ZigZag-encoded value\n * @returns Signed big integer\n */\nexport function zigZagDecodeBigInt(input: bigint): bigint {\n  return (input >> _1n) ^ -(input & _1n);\n}\n","import { isEmpty } from \"@fleet-sdk/common\";\nimport { type ByteInput, ensureBytes, hex } from \"@fleet-sdk/crypto\";\nimport { hexToBigInt } from \"./bigint\";\nimport { readBigVLQ, readVLQ } from \"./vlq\";\nimport { zigZagDecode, zigZagDecodeBigInt } from \"./zigZag\";\n\nexport class SigmaByteReader {\n  readonly #bytes: Uint8Array;\n  #cursor: number;\n\n  public get isEmpty(): boolean {\n    return isEmpty(this.#bytes);\n  }\n\n  constructor(bytes: ByteInput) {\n    this.#bytes = ensureBytes(bytes);\n    this.#cursor = 0;\n  }\n\n  public readBoolean(): boolean {\n    return this.readByte() === 0x01;\n  }\n\n  public readBits(length: number): ArrayLike<boolean> {\n    const bits = new Array<boolean>(length);\n    let bitOffset = 0;\n\n    for (let i = 0; i < length; i++) {\n      const bit = (this.#bytes[this.#cursor] >> bitOffset++) & 1;\n      bits[i] = bit === 1;\n\n      if (bitOffset === 8) {\n        bitOffset = 0;\n        this.#cursor++;\n      }\n    }\n\n    if (bitOffset > 0) this.#cursor++;\n\n    return bits;\n  }\n\n  public readByte(): number {\n    return this.#bytes[this.#cursor++];\n  }\n\n  public readBytes(length: number): Uint8Array {\n    return this.#bytes.subarray(this.#cursor, (this.#cursor += length));\n  }\n\n  public readVlq(): number {\n    return readVLQ(this);\n  }\n\n  public readShort(): number {\n    return Number(zigZagDecode(readVLQ(this)));\n  }\n\n  public readInt(): number {\n    return Number(this.readLong());\n  }\n\n  public readLong(): bigint {\n    return zigZagDecodeBigInt(readBigVLQ(this));\n  }\n\n  public readBigInt(): bigint {\n    const len = readVLQ(this);\n    return hexToBigInt(hex.encode(this.readBytes(len)));\n  }\n}\n","import { blake2b256, type Coder, hex } from \"@fleet-sdk/crypto\";\nimport { bigIntToHex } from \"./bigint\";\nimport { writeBigVLQ, writeVLQ } from \"./vlq\";\nimport { zigZagEncode, zigZagEncodeBigInt } from \"./zigZag\";\n\nexport class SigmaByteWriter {\n  readonly #bytes: Uint8Array;\n  #cursor: number;\n\n  public get length() {\n    return this.#cursor;\n  }\n\n  constructor(length: number) {\n    this.#bytes = new Uint8Array(length);\n    this.#cursor = 0;\n  }\n\n  public writeBoolean(value: boolean): SigmaByteWriter {\n    this.write(value === true ? 0x01 : 0x00);\n\n    return this;\n  }\n\n  public writeVLQ(value: number): SigmaByteWriter {\n    return writeVLQ(this, value);\n  }\n\n  public writeBigVLQ(value: bigint): SigmaByteWriter {\n    return writeBigVLQ(this, value);\n  }\n\n  public writeShort(value: number): SigmaByteWriter {\n    this.writeVLQ(zigZagEncode(value));\n    return this;\n  }\n\n  public writeInt(value: number): SigmaByteWriter {\n    this.writeLong(BigInt(value));\n    return this;\n  }\n\n  public writeLong(value: bigint): SigmaByteWriter {\n    this.writeBigVLQ(zigZagEncodeBigInt(value));\n    return this;\n  }\n\n  public write(byte: number): SigmaByteWriter {\n    this.#bytes[this.#cursor++] = byte;\n    return this;\n  }\n\n  public writeBytes(bytes: ArrayLike<number>): SigmaByteWriter {\n    this.#bytes.set(bytes, this.#cursor);\n    this.#cursor += bytes.length;\n    return this;\n  }\n\n  public writeHex(bytesHex: string): SigmaByteWriter {\n    return this.writeBytes(hex.decode(bytesHex));\n  }\n\n  public writeBits(bits: ArrayLike<boolean>): SigmaByteWriter {\n    let bitOffset = 0;\n\n    for (let i = 0; i < bits.length; i++) {\n      if (bits[i]) {\n        this.#bytes[this.#cursor] |= 1 << bitOffset++;\n      } else {\n        this.#bytes[this.#cursor] &= ~(1 << bitOffset++);\n      }\n\n      if (bitOffset === 8) {\n        bitOffset = 0;\n        this.#cursor++;\n      }\n    }\n\n    if (bitOffset > 0) this.#cursor++;\n\n    return this;\n  }\n\n  public writeBigInt(value: bigint): SigmaByteWriter {\n    const hex = bigIntToHex(value);\n    return this.writeVLQ(hex.length / 2).writeHex(hex);\n  }\n\n  public writeChecksum(length = 4, hashFn = blake2b256): SigmaByteWriter {\n    const hash = hashFn(this.toBytes());\n    return this.writeBytes(length ? hash.subarray(0, length) : hash);\n  }\n\n  public encode<T>(coder: Coder<Uint8Array, T>): T {\n    return coder.encode(this.toBytes());\n  }\n\n  public toBytes(): Uint8Array {\n    if (this.#cursor === this.#bytes.length) return this.#bytes;\n    return this.#bytes.subarray(0, this.#cursor);\n  }\n}\n","export abstract class SType<I = unknown, O = I> {\n  abstract get code(): number;\n  abstract get embeddable(): boolean;\n\n  coerce(data: I): O {\n    // a bit hacky but most of types will not need a specific coercion function.\n    return data as unknown as O;\n  }\n\n  abstract toString(): string;\n}\n\nexport abstract class SMonomorphicType<I, O = I> extends SType<I, O> {\n  abstract get code(): number;\n\n  get embeddable(): boolean {\n    return false;\n  }\n}\n\nexport abstract class SPrimitiveType<I, O = I> extends SMonomorphicType<I, O> {\n  abstract get code(): number;\n\n  override get embeddable(): boolean {\n    return true;\n  }\n}\n\nexport abstract class SGenericType<T extends SType | SType[]> extends SType {\n  readonly #internalType: T;\n\n  constructor(type: T) {\n    super();\n    this.#internalType = type;\n  }\n\n  abstract get code(): number;\n\n  get elementsType(): T {\n    return this.#internalType;\n  }\n\n  get embeddable(): boolean {\n    return false;\n  }\n}\n","import { ensureBigInt } from \"@fleet-sdk/common\";\nimport { hex } from \"@fleet-sdk/crypto\";\nimport type { SConstant } from \"../sigmaConstant\";\nimport { SPrimitiveType } from \"./base\";\nimport type { BigIntInput, ByteInput } from \"./constructors\";\n\nexport class SBoolType extends SPrimitiveType<boolean> {\n  get code(): 0x01 {\n    return 0x01;\n  }\n\n  toString(): string {\n    return \"SBool\";\n  }\n}\n\nexport class SByteType extends SPrimitiveType<number> {\n  get code(): 0x02 {\n    return 0x02;\n  }\n\n  toString(): string {\n    return \"SByte\";\n  }\n}\n\nexport class SShortType extends SPrimitiveType<number> {\n  get code(): 0x03 {\n    return 0x03;\n  }\n\n  toString(): string {\n    return \"SShort\";\n  }\n}\n\nexport class SIntType extends SPrimitiveType<number> {\n  get code(): 0x04 {\n    return 0x04;\n  }\n\n  toString(): string {\n    return \"SInt\";\n  }\n}\n\nexport class SLongType extends SPrimitiveType<BigIntInput, bigint> {\n  get code(): 0x05 {\n    return 0x05;\n  }\n\n  override coerce(data: BigIntInput): bigint {\n    return ensureBigInt(data);\n  }\n\n  toString(): string {\n    return \"SLong\";\n  }\n}\n\nexport class SBigIntType extends SPrimitiveType<string | bigint, bigint> {\n  get code(): number {\n    return 0x06;\n  }\n\n  override coerce(data: BigIntInput): bigint {\n    return ensureBigInt(data);\n  }\n\n  toString(): string {\n    return \"SBigInt\";\n  }\n}\n\nexport class SGroupElementType extends SPrimitiveType<ByteInput, Uint8Array> {\n  get code(): 0x07 {\n    return 0x07;\n  }\n\n  override coerce(data: ByteInput): Uint8Array {\n    return typeof data === \"string\" ? hex.decode(data) : data;\n  }\n\n  toString(): string {\n    return \"SGroupElement\";\n  }\n}\n\nexport class SSigmaPropType extends SPrimitiveType<SConstant<Uint8Array>> {\n  get code(): 0x08 {\n    return 0x08;\n  }\n\n  toString(): string {\n    return \"SSigmaProp\";\n  }\n}\n","import { SMonomorphicType } from \"./base\";\n\nexport class SUnitType extends SMonomorphicType<undefined> {\n  get code(): 0x62 {\n    return 0x62;\n  }\n\n  toString(): string {\n    return \"SUnit\";\n  }\n}\n","import type { SType } from \"./base\";\nimport type { SCollType, STupleType } from \"./generics\";\nimport { SUnitType } from \"./monomorphics\";\nimport {\n  SBigIntType,\n  SBoolType,\n  SByteType,\n  SGroupElementType,\n  SIntType,\n  SLongType,\n  SShortType,\n  SSigmaPropType\n} from \"./primitives\";\n\nexport const constructorCode = Object.freeze({\n  embeddable: 0,\n\n  simpleColl: 1,\n  nestedColl: 2,\n\n  option: 3,\n  optionCollection: 4,\n\n  pairOne: 5,\n  pairTwo: 6,\n  symmetricPair: 7,\n  genericTuple: 8\n});\n\nconst MAX_PRIMITIVE_TYPE_CODE = 0x0b;\nexport const PRIMITIVE_TYPE_RANGE = MAX_PRIMITIVE_TYPE_CODE + 0x01;\nconst typeCodeOf = (ctor: number) => PRIMITIVE_TYPE_RANGE * ctor;\n\ntype Descriptor = { code: number; embeddable: boolean };\n\nconst collDescriptor = Object.freeze({\n  code: typeCodeOf(constructorCode.simpleColl),\n  embeddable: false,\n  simpleCollTypeCode: typeCodeOf(constructorCode.simpleColl),\n  nestedCollTypeCode: typeCodeOf(constructorCode.nestedColl)\n}) satisfies Descriptor;\n\nconst tupleDescriptor = Object.freeze({\n  code: typeCodeOf(constructorCode.pairOne),\n  embeddable: false,\n  pairOneTypeCode: typeCodeOf(constructorCode.pairOne),\n  pairTwoTypeCode: typeCodeOf(constructorCode.pairTwo),\n  tripleTypeCode: typeCodeOf(constructorCode.pairTwo),\n  symmetricPairTypeCode: typeCodeOf(constructorCode.symmetricPair),\n  quadrupleTypeCode: typeCodeOf(constructorCode.symmetricPair),\n  genericTupleTypeCode: typeCodeOf(constructorCode.genericTuple)\n}) satisfies Descriptor;\n\nexport const descriptors = {\n  bool: new SBoolType(),\n  byte: new SByteType(),\n  short: new SShortType(),\n  int: new SIntType(),\n  long: new SLongType(),\n  bigInt: new SBigIntType(),\n  groupElement: new SGroupElementType(),\n  sigmaProp: new SSigmaPropType(),\n  unit: new SUnitType(),\n  coll: collDescriptor,\n  tuple: tupleDescriptor\n} satisfies { [key: string]: Descriptor };\n\nexport function isColl(type: SType): type is SCollType {\n  return (\n    type.code >= descriptors.coll.simpleCollTypeCode &&\n    type.code <= descriptors.coll.nestedCollTypeCode + MAX_PRIMITIVE_TYPE_CODE\n  );\n}\n\nexport function isTuple(type: SType): type is STupleType {\n  return (\n    type.code >= descriptors.tuple.pairOneTypeCode &&\n    type.code <= descriptors.tuple.genericTupleTypeCode\n  );\n}\n\nexport function getPrimitiveType(typeCode: number) {\n  switch (typeCode) {\n    case descriptors.bool.code:\n      return descriptors.bool;\n    case descriptors.byte.code:\n      return descriptors.byte;\n    case descriptors.short.code:\n      return descriptors.short;\n    case descriptors.int.code:\n      return descriptors.int;\n    case descriptors.long.code:\n      return descriptors.long;\n    case descriptors.bigInt.code:\n      return descriptors.bigInt;\n    case descriptors.groupElement.code:\n      return descriptors.groupElement;\n    case descriptors.sigmaProp.code:\n      return descriptors.sigmaProp;\n    default:\n      throw new Error(\n        `The type code '0x${typeCode.toString(16)}' is not a valid primitive type code.`\n      );\n  }\n}\n","import { hex } from \"@fleet-sdk/crypto\";\nimport { SGenericType, type SType } from \"./base\";\nimport { descriptors } from \"./descriptors\";\n\nexport class SCollType<T extends SType = SType> extends SGenericType<T> {\n  get code(): number {\n    return descriptors.coll.code;\n  }\n\n  override coerce<I, O>(elements: I[]): O[] | Uint8Array {\n    if (\n      this.elementsType.code === descriptors.byte.code &&\n      !(elements instanceof Uint8Array)\n    ) {\n      return typeof elements === \"string\"\n        ? hex.decode(elements)\n        : Uint8Array.from(elements as ArrayLike<number>);\n    }\n\n    return elements.map((el) => this.elementsType.coerce(el)) as O[];\n  }\n\n  toString(): string {\n    return `SColl[${this.elementsType.toString()}]`;\n  }\n}\n\nexport class STupleType<T extends SType[] = SType[]> extends SGenericType<T> {\n  get code(): number {\n    return descriptors.tuple.code;\n  }\n\n  override coerce<I, O>(elements: I[]): O[] {\n    const output = new Array(elements.length);\n    for (let i = 0; i < elements.length; i++) {\n      output[i] = this.elementsType[i].coerce(elements[i]);\n    }\n\n    return output;\n  }\n\n  toString(): string {\n    return `(${this.elementsType.map((el) => el.toString()).join(\", \")})`;\n  }\n}\n","import { isEmpty } from \"@fleet-sdk/common\";\nimport { SConstant } from \"../sigmaConstant\";\nimport type { SType } from \"./base\";\nimport { descriptors } from \"./descriptors\";\nimport { SCollType, STupleType } from \"./generics\";\nimport { SUnitType } from \"./monomorphics\";\nimport {\n  SBigIntType,\n  SBoolType,\n  SByteType,\n  SGroupElementType,\n  SIntType,\n  SLongType,\n  SShortType,\n  SSigmaPropType\n} from \"./primitives\";\n\nexport type BigIntInput = string | bigint;\nexport type ByteInput = Uint8Array | string;\n\nexport type SConstructor<T = unknown, S extends SType = SType | SCollType<SType>> = (\n  arg?: T\n) => S;\n\n// biome-ignore lint/suspicious/noExplicitAny: <explanation>\ntype Any = any;\n\ntype Constructable<T = Any> = { new (...args: Any): T };\ntype GenericProxyArgs<R> = R extends (...args: Any) => unknown ? Parameters<R> : [];\n\ntype SProxy<T extends SType, I, O = I> = {\n  (value: I): SConstant<O, T>;\n  (value?: I): T;\n};\n\n/**\n * Creates a proxy for monomorphic types, this allows constructor\n * functions to be equivalent to their corresponding type.\n *\n * This function will return one instance of `ctor` if not params as set.\n * Otherwise it will return an `SigmaConstant` instance of `ctor` type.\n *\n * @example\n * // SInt is a proxy for SIntType\n * (intConstant instanceof SInt) === true\n * (intConstant instanceof SIntType) === true\n * @param ctor Class to be proxied.\n * @param cache If defined, proxy will return this instead of a new instance of `ctor`.\n * @param forceConstruction If true, bypasses the constant creation and returns a type.\n * @returns\n */\nfunction monoProxy<T extends SType, I, O = I>(\n  ctor: Constructable<T>,\n  cache?: T,\n  forceConstruction?: boolean\n): SProxy<T, I, O> {\n  return new Proxy(ctor, {\n    apply: (target, _, args) => {\n      const instance = cache ?? new target();\n      if (!forceConstruction && isEmpty(args)) return instance;\n\n      return new (SConstant as Constructable)(instance, ...args);\n    }\n  }) as Any;\n}\n\n/**\n * Creates a proxy for generic types.\n */\nfunction genericProxy<T extends SType, R>(\n  ctor: Constructable<T>,\n  handler: (\n    target: Constructable<T>,\n    thisArgs: unknown,\n    args: GenericProxyArgs<R>\n  ) => unknown\n) {\n  return new Proxy(ctor, {\n    apply: handler\n  }) as R;\n}\n\nexport const SByte = monoProxy<SByteType, number>(SByteType, descriptors.byte);\n\nexport const SBool = monoProxy<SBoolType, boolean>(SBoolType, descriptors.bool);\n\nexport const SShort = monoProxy<SShortType, number>(SShortType, descriptors.short);\n\nexport const SInt = monoProxy<SIntType, number>(SIntType, descriptors.int);\n\nexport const SLong = monoProxy<SLongType, BigIntInput, bigint>(\n  SLongType,\n  descriptors.long\n);\n\nexport const SBigInt = monoProxy<SBigIntType, BigIntInput, bigint>(\n  SBigIntType,\n  descriptors.bigInt\n);\n\nexport const SGroupElement = monoProxy<SGroupElementType, ByteInput, Uint8Array>(\n  SGroupElementType,\n  descriptors.groupElement\n);\n\nexport const SSigmaProp = monoProxy<SSigmaPropType, SConstant<Uint8Array>>(\n  SSigmaPropType,\n  descriptors.sigmaProp\n);\n\ntype SUnit = (value?: undefined) => SConstant<undefined, SUnitType>;\nexport const SUnit: SUnit = monoProxy(SUnitType, undefined, true);\n\ntype SColl = {\n  <D, T extends SType>(type: SConstructor<D, T>): SConstructor<D[], T>;\n  <D, T extends SByteType>(\n    type: SConstructor<D, T>,\n    elements: ByteInput | D[]\n  ): SConstant<Uint8Array, T>;\n  <D, T extends SType>(type: SConstructor<D, T>, elements: D[]): SConstant<D[], T>;\n};\n\nexport const SColl = genericProxy<SCollType, SColl>(SCollType, (target, _, args) => {\n  const [type, elements] = args;\n  const elementsType = type();\n  if (!elements) return () => new target(elementsType);\n\n  return new SConstant(new target(elementsType), elements);\n});\n\nexport function STuple(...items: SConstant[]) {\n  return new SConstant(\n    new STupleType(items.map((x) => x.type)),\n    items.map((x) => x.data)\n  );\n}\n\ntype ByteInputOr<D, T extends SType> = T extends SByteType ? ByteInput | D : D;\ntype SPair = {\n  <L, R>(left: SConstant<L>, right: SConstant<R>): SConstant<[L, R], STupleType>;\n  <LD, RD, LT extends SType, RT extends SType>(\n    left: SConstructor<LD, LT>,\n    right: SConstructor<RD, RT>\n  ): SConstructor<[ByteInputOr<LD, LT>, ByteInputOr<RD, RT>]>;\n};\n\nexport const SPair = genericProxy<STupleType, SPair>(STupleType, (target, _, args) => {\n  const [left, right] = args;\n\n  if (typeof left === \"function\" && typeof right === \"function\") {\n    return () => new target([left(), right()]);\n  }\n\n  if (left instanceof SConstant && right instanceof SConstant) {\n    return new SConstant(new target([left.type, right.type]), [left.data, right.data]);\n  }\n\n  throw new Error(\"Invalid tuple declaration.\");\n});\n","import { assert } from \"@fleet-sdk/common\";\nimport type { SigmaByteReader, SigmaByteWriter } from \"../coders\";\nimport type { SConstant } from \"../sigmaConstant\";\nimport { isColl, isTuple, type SCollType, type STupleType, type SType } from \"../types\";\nimport { descriptors } from \"../types/descriptors\";\n\nconst GROUP_ELEMENT_LENGTH = 33;\nconst PROVE_DLOG_OP = 0xcd;\n\nexport const dataSerializer = {\n  serialize(data: unknown, type: SType, writer: SigmaByteWriter): SigmaByteWriter {\n    if (type.embeddable) {\n      switch (type.code) {\n        case descriptors.bool.code:\n          return writer.writeBoolean(data as boolean);\n        case descriptors.byte.code:\n          return writer.write(data as number);\n        case descriptors.short.code:\n          return writer.writeShort(data as number);\n        case descriptors.int.code:\n          return writer.writeInt(data as number);\n        case descriptors.long.code:\n          return writer.writeLong(data as bigint);\n        case descriptors.bigInt.code:\n          return writer.writeBigInt(data as bigint);\n        case descriptors.groupElement.code:\n          return writer.writeBytes(data as Uint8Array);\n        case descriptors.sigmaProp.code: {\n          const node = data as SConstant<SConstant<Uint8Array>>;\n          if (node.type === descriptors.groupElement) {\n            writer.write(PROVE_DLOG_OP);\n            return dataSerializer.serialize(node.data, node.type, writer);\n          }\n\n          throw Error(\"Serialization error: SigmaProp operation not implemented.\");\n        }\n      }\n    }\n\n    if (isColl(type)) {\n      if (type.elementsType.code === descriptors.byte.code) {\n        assert(\n          data instanceof Uint8Array,\n          `SColl[Byte] expected an UInt8Array, got ${typeof data}.`\n        );\n      } else {\n        assert(Array.isArray(data), `SColl expected an array, got ${typeof data}.`);\n      }\n\n      writer.writeVLQ(data.length);\n      switch (type.elementsType.code) {\n        case descriptors.bool.code: {\n          return writer.writeBits(data as boolean[]);\n        }\n        case descriptors.byte.code: {\n          return writer.writeBytes(data as Uint8Array);\n        }\n        default: {\n          for (let i = 0; i < data.length; i++) {\n            dataSerializer.serialize(data[i], type.elementsType, writer);\n          }\n\n          return writer;\n        }\n      }\n    }\n\n    if (isTuple(type)) {\n      assert(\n        Array.isArray(data),\n        `STupleType serialization expected an array, got ${typeof data}.`\n      );\n\n      const len = type.elementsType.length;\n      for (let i = 0; i < len; i++) {\n        dataSerializer.serialize(data[i], type.elementsType[i], writer);\n      }\n\n      return writer;\n    }\n\n    if (type.code === descriptors.unit.code) return writer;\n\n    throw Error(\n      `Serialization error: '0x${type.code.toString(16)}' type not implemented.`\n    );\n  },\n\n  deserialize(type: SType, reader: SigmaByteReader): unknown {\n    if (type.embeddable) {\n      switch (type.code) {\n        case descriptors.bool.code:\n          return reader.readBoolean();\n        case descriptors.byte.code:\n          return reader.readByte();\n        case descriptors.short.code:\n          return reader.readShort();\n        case descriptors.int.code:\n          return reader.readInt();\n        case descriptors.long.code:\n          return reader.readLong();\n        case descriptors.bigInt.code:\n          return reader.readBigInt();\n        case descriptors.groupElement.code:\n          return reader.readBytes(GROUP_ELEMENT_LENGTH);\n        case descriptors.sigmaProp.code: {\n          if (reader.readByte() === PROVE_DLOG_OP) {\n            return this.deserialize(descriptors.groupElement, reader);\n          }\n\n          break;\n        }\n      }\n    } else {\n      switch (type.code) {\n        case descriptors.coll.code: {\n          const length = reader.readVlq();\n          const embeddedType = (type as SCollType).elementsType;\n\n          switch (embeddedType.code) {\n            case descriptors.bool.code:\n              return reader.readBits(length);\n            case descriptors.byte.code:\n              return reader.readBytes(length);\n            default: {\n              const elements = new Array(length);\n              for (let i = 0; i < length; i++) {\n                elements[i] = this.deserialize(embeddedType, reader);\n              }\n\n              return elements;\n            }\n          }\n        }\n        case descriptors.tuple.code: {\n          return (type as STupleType).elementsType.map((t) =>\n            this.deserialize(t, reader)\n          );\n        }\n        case descriptors.unit.code:\n          return undefined;\n      }\n    }\n\n    throw new Error(`Parsing error: '0x${type.code.toString(16)}' type not implemented.`);\n  }\n};\n","import { assert, first, last } from \"@fleet-sdk/common\";\nimport type { SigmaByteReader, SigmaByteWriter } from \"../coders\";\nimport { isColl, isTuple, SCollType, STupleType, type SType } from \"../types\";\nimport {\n  constructorCode,\n  descriptors,\n  getPrimitiveType,\n  PRIMITIVE_TYPE_RANGE\n} from \"../types/descriptors\";\n\nexport const typeSerializer = {\n  serialize(type: SType, writer: SigmaByteWriter) {\n    if (type.embeddable) {\n      writer.write(type.code);\n    } else if (type.code === descriptors.unit.code) {\n      writer.write(type.code);\n    } else if (isColl(type)) {\n      if (type.elementsType.embeddable) {\n        writer.write(descriptors.coll.simpleCollTypeCode + type.elementsType.code);\n      } else if (isColl(type.elementsType)) {\n        const nestedColl = type.elementsType;\n        if (nestedColl.elementsType.embeddable) {\n          writer.write(\n            descriptors.coll.nestedCollTypeCode + nestedColl.elementsType.code\n          );\n        } else {\n          writer.write(descriptors.coll.simpleCollTypeCode);\n          this.serialize(nestedColl, writer);\n        }\n      } else {\n        writer.write(descriptors.coll.simpleCollTypeCode);\n        this.serialize(type.elementsType, writer);\n      }\n    } else if (isTuple(type)) {\n      switch (type.elementsType.length) {\n        case 2: {\n          const left = first(type.elementsType);\n          const right = last(type.elementsType);\n\n          if (left.embeddable) {\n            if (left.code === right.code) {\n              // Symmetric pair of primitive types (`(Int, Int)`, `(Byte,Byte)`, etc.)\n              writer.write(descriptors.tuple.symmetricPairTypeCode + left.code);\n            } else {\n              // Pair of types where first is primitive (`(_, Int)`)\n              writer.write(descriptors.tuple.pairOneTypeCode + left.code);\n              this.serialize(right, writer);\n            }\n          } else if (right.embeddable) {\n            // Pair of types where second is primitive (`(Int, _)`)\n            writer.write(descriptors.tuple.pairTwoTypeCode + right.code);\n            this.serialize(left, writer);\n          } else {\n            // Pair of non-primitive types (`((Int, Byte), (Boolean,Box))`, etc.)\n            writer.write(descriptors.tuple.pairOneTypeCode);\n            this.serialize(left, writer);\n            this.serialize(right, writer);\n          }\n\n          return;\n        }\n        case 3:\n          writer.write(descriptors.tuple.tripleTypeCode);\n          break;\n        case 4:\n          writer.write(descriptors.tuple.quadrupleTypeCode);\n          break;\n        default: {\n          const len = type.elementsType.length;\n          assert(\n            len >= 2 && len <= 255,\n            \"Invalid type: tuples must have between 2 and 255 items.\"\n          );\n\n          // Generic tuple\n          writer.write(descriptors.tuple.genericTupleTypeCode);\n          writer.writeVLQ(len);\n        }\n      }\n\n      for (let i = 0; i < type.elementsType.length; i++) {\n        this.serialize(type.elementsType[i], writer);\n      }\n    } else {\n      throw new Error(\"Serialization error: type not implemented.\");\n    }\n  },\n\n  deserialize(r: SigmaByteReader): SType {\n    const byte = r.readByte();\n    assert(byte > 0, `Parsing Error: Unexpected type code '0x${byte.toString(16)}'`);\n\n    if (byte < descriptors.tuple.genericTupleTypeCode) {\n      const ctorCode = Math.floor(byte / PRIMITIVE_TYPE_RANGE);\n      const embdCode = Math.floor(byte % PRIMITIVE_TYPE_RANGE);\n\n      switch (ctorCode) {\n        case constructorCode.embeddable: {\n          return getPrimitiveType(embdCode);\n        }\n        case constructorCode.simpleColl: {\n          const internal =\n            embdCode === 0 ? this.deserialize(r) : getPrimitiveType(embdCode);\n\n          return new SCollType(internal);\n        }\n        case constructorCode.nestedColl: {\n          return new SCollType(new SCollType(getPrimitiveType(embdCode)));\n        }\n        case constructorCode.pairOne: {\n          const internal =\n            embdCode === 0\n              ? [this.deserialize(r), this.deserialize(r)] // Pair of non-primitive types (`((Int, Byte), (Boolean,Box))`, etc.)\n              : [getPrimitiveType(embdCode), this.deserialize(r)]; // Pair of types where first is primitive (`(_, Int)`)\n\n          return new STupleType(internal);\n        }\n        case constructorCode.pairTwo: {\n          const internal =\n            embdCode === 0\n              ? [this.deserialize(r), this.deserialize(r), this.deserialize(r)] // Triple of types\n              : [this.deserialize(r), getPrimitiveType(embdCode)];\n\n          return new STupleType(internal);\n        }\n        case constructorCode.symmetricPair: {\n          const internal =\n            embdCode === 0\n              ? [\n                  this.deserialize(r),\n                  this.deserialize(r),\n                  this.deserialize(r),\n                  this.deserialize(r)\n                ] // Quadruple of types\n              : [getPrimitiveType(embdCode), getPrimitiveType(embdCode)]; // Symmetric pair of primitive types (`(Int, Int)`, `(Byte,Byte)`, etc.)\n\n          return new STupleType(internal);\n        }\n      }\n    }\n\n    switch (byte) {\n      case descriptors.tuple.genericTupleTypeCode: {\n        const len = r.readVlq();\n        const wrapped = new Array<SType>(len);\n        for (let i = 0; i < len; i++) {\n          wrapped[i] = this.deserialize(r);\n        }\n\n        return new STupleType(wrapped);\n      }\n      case descriptors.unit.code: {\n        return descriptors.unit;\n      }\n    }\n\n    throw new Error(\"Not implemented.\");\n  }\n};\n","import { assert, isUndefined } from \"@fleet-sdk/common\";\nimport { type ByteInput, hex } from \"@fleet-sdk/crypto\";\nimport { SigmaByteReader, SigmaByteWriter } from \"./coders\";\nimport { dataSerializer } from \"./serializers/dataSerializer\";\nimport { typeSerializer } from \"./serializers/typeSerializer\";\nimport type { SType } from \"./types\";\n\nexport const MAX_CONSTANT_LENGTH = 4096;\n\nexport class SConstant<D = unknown, T extends SType = SType> {\n  readonly #type: T;\n  readonly #data: D;\n\n  constructor(type: T, data: D) {\n    this.#type = type;\n    this.#data = type.coerce(data) as D;\n  }\n\n  static from<D, T extends SType = SType>(bytes: ByteInput): SConstant<D, T> {\n    assert(bytes.length > 0, \"Empty constant bytes.\");\n\n    const reader = new SigmaByteReader(bytes);\n    const type = typeSerializer.deserialize(reader);\n    const data = dataSerializer.deserialize(type, reader);\n\n    return new SConstant(type as T, data as D);\n  }\n\n  get type(): T {\n    return this.#type;\n  }\n\n  get data(): D {\n    return this.#data;\n  }\n\n  toBytes(): Uint8Array {\n    const writer = new SigmaByteWriter(MAX_CONSTANT_LENGTH);\n    typeSerializer.serialize(this.type, writer);\n    dataSerializer.serialize(this.data, this.type, writer);\n\n    return writer.toBytes();\n  }\n\n  toHex(): string {\n    return hex.encode(this.toBytes());\n  }\n}\n\n/**\n * Decodes a byte input into a Sigma constant of type `SConstant<D, T>`.\n *\n * @template D - The data type of the constant.\n * @template T - The type of the constant.\n * @param value - The value to decode.\n * @returns The decoded constant or `undefined` if the value is `undefined` or decoding fails.\n */\nexport function decode<D = unknown, T extends SType = SType>(\n  value?: ByteInput\n): SConstant<D, T> | undefined {\n  if (value === undefined) return;\n\n  try {\n    return SConstant.from<D, T>(value);\n  } catch {\n    return;\n  }\n}\n\n/**\n * Returns the `SType` of the given value.\n *\n * @param value - The value to check the SType of.\n * @returns The SType of the value, or `undefined` if the value is `undefined` or\n * deserialization fails.\n */\nexport function stypeof(value?: ByteInput): SType | undefined {\n  if (!value) return;\n\n  try {\n    return typeSerializer.deserialize(new SigmaByteReader(value));\n  } catch {\n    return;\n  }\n}\n\n/** @deprecated use `decode` instead */\nexport function parse<T>(constant: ByteInput): T;\n/** @deprecated use `decode` instead */\nexport function parse<T>(constant: ByteInput, mode: \"strict\"): T;\n/** @deprecated use `decode` instead */\nexport function parse<T>(constant: ByteInput | undefined, mode: \"safe\"): T | undefined;\n/** @deprecated use `decode` instead */\nexport function parse<T>(\n  constant: ByteInput | undefined,\n  mode: \"strict\" | \"safe\" = \"strict\"\n) {\n  if (mode === \"strict\") return SConstant.from<T>(constant ?? \"\").data;\n  if (!constant) return;\n\n  try {\n    return SConstant.from<T>(constant).data;\n  } catch {\n    return;\n  }\n}\n","import {\n  type Amount,\n  type Box,\n  type BoxCandidate,\n  byteSizeOf,\n  ensureBigInt,\n  isDefined,\n  isEmpty,\n  isUndefined,\n  type NonMandatoryRegisters,\n  some,\n  type TokenAmount\n} from \"@fleet-sdk/common\";\nimport { estimateVLQSize, SigmaByteWriter } from \"../coders\";\n\nconst MAX_UINT16_VALUE = 65535;\n\nexport function serializeBox(box: Box<Amount>): SigmaByteWriter;\nexport function serializeBox(box: Box<Amount>, writer: SigmaByteWriter): SigmaByteWriter;\nexport function serializeBox(\n  box: BoxCandidate<Amount>,\n  writer: SigmaByteWriter,\n  distinctTokenIds: string[]\n): SigmaByteWriter;\nexport function serializeBox(\n  box: Box<Amount> | BoxCandidate<Amount>,\n  writer = new SigmaByteWriter(5_0000),\n  distinctTokenIds?: string[]\n): SigmaByteWriter {\n  writer.writeBigVLQ(ensureBigInt(box.value));\n  writer.writeHex(box.ergoTree);\n  writer.writeVLQ(box.creationHeight);\n  writeTokens(writer, box.assets, distinctTokenIds);\n  writeRegisters(writer, box.additionalRegisters);\n\n  if (isDefined(distinctTokenIds)) return writer;\n  if (!isBox(box)) throw new Error(\"Invalid box type.\");\n  return writer.writeHex(box.transactionId).writeVLQ(box.index);\n}\n\nfunction isBox<T extends Amount>(box: Box<Amount> | BoxCandidate<Amount>): box is Box<T> {\n  const castedBox = box as Box<T>;\n\n  return isDefined(castedBox.transactionId) && isDefined(castedBox.index);\n}\n\nfunction writeTokens(\n  writer: SigmaByteWriter,\n  tokens: TokenAmount<Amount>[],\n  tokenIds?: string[]\n): void {\n  if (isEmpty(tokens)) {\n    writer.write(0);\n\n    return;\n  }\n\n  writer.writeVLQ(tokens.length);\n  if (some(tokenIds)) {\n    tokens.map((token) =>\n      writer\n        .writeVLQ(tokenIds.indexOf(token.tokenId))\n        .writeBigVLQ(ensureBigInt(token.amount))\n    );\n  } else {\n    tokens.map((token) =>\n      writer.writeHex(token.tokenId).writeBigVLQ(ensureBigInt(token.amount))\n    );\n  }\n}\n\nfunction writeRegisters(writer: SigmaByteWriter, registers: NonMandatoryRegisters): void {\n  const keys = Object.keys(registers).sort();\n  let length = 0;\n\n  for (const key of keys) {\n    if (registers[key as keyof NonMandatoryRegisters]) length++;\n  }\n\n  writer.writeVLQ(length);\n  if (length === 0) return;\n\n  for (const key of keys) {\n    const register = registers[key as keyof NonMandatoryRegisters];\n    if (isDefined(register)) writer.writeHex(register);\n  }\n}\n\n/**\n * Estimates the byte size a box.\n * @returns byte size of the box.\n */\nexport function estimateBoxSize(\n  box: Box<Amount> | BoxCandidate<Amount>,\n  withValue?: Amount\n): number {\n  if (isUndefined(box.creationHeight)) {\n    throw new Error(\"Box size estimation error: creation height is undefined.\");\n  }\n\n  let size = 0;\n\n  size += estimateVLQSize(isDefined(withValue) ? withValue : box.value);\n  size += byteSizeOf(box.ergoTree);\n  size += estimateVLQSize(box.creationHeight);\n\n  size += estimateVLQSize(box.assets.length);\n  for (const asset of box.assets) {\n    size += byteSizeOf(asset.tokenId) + estimateVLQSize(asset.amount);\n  }\n\n  let registersLength = 0;\n  for (const key in box.additionalRegisters) {\n    const register = box.additionalRegisters[key as keyof NonMandatoryRegisters];\n    if (register) {\n      size += byteSizeOf(register);\n      registersLength++;\n    }\n  }\n\n  size += estimateVLQSize(registersLength);\n  size += 32; // transaction id (BLAKE2b 256 hash)\n  size += estimateVLQSize(isBox(box) ? box.index : MAX_UINT16_VALUE);\n\n  return size;\n}\n","import {\n  type Amount,\n  type BoxCandidate,\n  type ContextExtension,\n  type DataInput,\n  isDefined,\n  type UnsignedInput\n} from \"@fleet-sdk/common\";\nimport { SigmaByteWriter } from \"../coders\";\nimport { serializeBox } from \"./boxSerializer\";\n\nexport type MinimalUnsignedTransaction = {\n  inputs: readonly UnsignedInput[];\n  dataInputs: readonly DataInput[];\n  outputs: readonly BoxCandidate<Amount>[];\n};\n\nexport function serializeTransaction(\n  transaction: MinimalUnsignedTransaction\n): SigmaByteWriter {\n  const writer = new SigmaByteWriter(100_000);\n\n  // write inputs\n  writer.writeVLQ(transaction.inputs.length);\n  transaction.inputs.map((input) => writeInput(writer, input));\n\n  // write data inputs\n  writer.writeVLQ(transaction.dataInputs.length);\n  transaction.dataInputs.map((dataInput) => writer.writeHex(dataInput.boxId));\n\n  // write distinct token IDs\n  const distinctTokenIds = getDistinctTokenIds(transaction.outputs);\n  writer.writeVLQ(distinctTokenIds.length);\n  distinctTokenIds.map((tokenId) => writer.writeHex(tokenId));\n\n  // write outputs\n  writer.writeVLQ(transaction.outputs.length);\n  transaction.outputs.map((output) => serializeBox(output, writer, distinctTokenIds));\n\n  return writer;\n}\n\nfunction writeInput(writer: SigmaByteWriter, input: UnsignedInput): void {\n  writer.writeHex(input.boxId);\n  writer.write(0); // empty proof\n  writeExtension(writer, input.extension);\n}\n\nfunction writeExtension(writer: SigmaByteWriter, extension: ContextExtension): void {\n  const keys = Object.keys(extension);\n  let length = 0;\n\n  for (const key of keys) {\n    const ext = extension[key as unknown as keyof ContextExtension];\n    if (isDefined(ext)) {\n      length++;\n    }\n  }\n\n  writer.writeVLQ(length);\n  if (length === 0) return;\n\n  for (const key of keys) {\n    const ext = extension[key as unknown as keyof ContextExtension];\n    if (isDefined(ext)) {\n      writer.writeVLQ(Number(key)).writeHex(ext);\n    }\n  }\n}\n\nfunction getDistinctTokenIds(outputs: readonly BoxCandidate<Amount>[]) {\n  const tokenIds = new Set<string>();\n  outputs.flatMap((output) => output.assets.map((asset) => tokenIds.add(asset.tokenId)));\n\n  return Array.from(tokenIds);\n}\n"]}