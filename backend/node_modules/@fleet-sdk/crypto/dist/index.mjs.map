{"version":3,"sources":["../src/coders/hex.ts","../src/coders/utf8.ts","../src/coders/bigintBE.ts","../src/coders/index.ts","../src/hashes.ts","../src/ecpoint.ts","../src/index.ts"],"names":["hex","assertInstanceOf","assertTypeOf","base58checkCoder","base58Coder","base64Coder","_sha256","nobleRandomBytes"],"mappings":"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","file":"index.mjs","sourcesContent":["import { assert, assertInstanceOf, assertTypeOf } from \"@fleet-sdk/common\";\nimport type { BytesCoder } from \"../types\";\n\nconst HEXES = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, \"0\"));\n\nconst HexChar = {\n  ZERO: 48, // 0\n  NINE: 57, // 9\n  A_UP: 65, // A\n  F_UP: 70, // F\n  A_LO: 97, // a\n  F_LO: 102 // f\n} as const;\n\nfunction bytesToHex(bytes: Uint8Array): string {\n  assertInstanceOf(bytes, Uint8Array);\n\n  let hex = \"\";\n  for (let i = 0, len = bytes.length; i < len; i++) {\n    hex += HEXES[bytes[i]];\n  }\n\n  return hex;\n}\n\nfunction hexToBytes(hex: string): Uint8Array {\n  assertTypeOf(hex, \"string\");\n  assert(hex.length % 2 === 0, \"Invalid hex padding.\");\n\n  const len = hex.length / 2;\n  const bytes = new Uint8Array(len);\n  for (let i = 0, j = 0; i < len; i++) {\n    const n1 = charCodeToBase16(hex.charCodeAt(j++));\n    const n2 = charCodeToBase16(hex.charCodeAt(j++));\n    bytes[i] = n1 * 16 + n2;\n  }\n\n  return bytes;\n}\n\nfunction charCodeToBase16(char: number) {\n  if (char >= HexChar.ZERO && char <= HexChar.NINE) return char - HexChar.ZERO;\n  if (char >= HexChar.A_UP && char <= HexChar.F_UP) return char - (HexChar.A_UP - 10);\n  if (char >= HexChar.A_LO && char <= HexChar.F_LO) return char - (HexChar.A_LO - 10);\n\n  throw new Error(\"Invalid byte sequence.\");\n}\n\nexport const hex: BytesCoder = {\n  encode: bytesToHex,\n  decode: hexToBytes\n};\n","import { assertInstanceOf, assertTypeOf } from \"@fleet-sdk/common\";\nimport type { BytesCoder } from \"../types\";\n\nfunction bytesToUtf8(bytes: Uint8Array): string {\n  assertInstanceOf(bytes, Uint8Array);\n\n  return new TextDecoder().decode(bytes);\n}\n\nfunction utf8ToBytes(str: string): Uint8Array {\n  assertTypeOf(str, \"string\");\n\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\nexport const utf8: BytesCoder = {\n  encode: bytesToUtf8,\n  decode: utf8ToBytes\n};\n","import { hex } from \"@scure/base\";\nimport type { Coder } from \"../types\";\n\n/**\n * A coder for Big Endian  `BigInt` <> `Uint8Array` conversion..\n */\nexport const bigintBE: Coder<Uint8Array, bigint> = {\n  /**\n   * Encode a `Uint8Array` to a `BigInt`.\n   */\n  encode(data) {\n    const hexInput = hex.encode(data);\n    return BigInt(hexInput === \"\" ? \"0\" : `0x${hexInput}`);\n  },\n\n  /**\n   * Decode a `BigInt` to a `Uint8Array`.\n   */\n  decode(data) {\n    const hexData = data.toString(16);\n    return hex.decode(hexData.length % 2 ? `0${hexData}` : hexData);\n  }\n};\n","import {\n  base58check as base58checkCoder,\n  base58 as base58Coder,\n  base64 as base64Coder\n} from \"@scure/base\";\nimport { sha256 } from \"../hashes\";\nimport type { BytesCoder } from \"../types\";\n\nexport const base58check = base58checkCoder(sha256);\nexport const base58 = base58Coder as BytesCoder;\nexport const base64 = base64Coder as BytesCoder;\n\nexport { hex } from \"./hex\";\nexport { utf8 } from \"./utf8\";\nexport { bigintBE } from \"./bigintBE\";\n","import { blake2b } from \"@noble/hashes/blake2b\";\nimport { sha256 as _sha256 } from \"@noble/hashes/sha256\";\nimport { hex } from \"./coders\";\nimport type { ByteInput } from \"./types\";\n\nexport function ensureBytes(input: ByteInput): Uint8Array {\n  return typeof input === \"string\" ? hex.decode(input) : input;\n}\n\nexport function blake2b256(message: ByteInput): Uint8Array {\n  return blake2b(ensureBytes(message), { dkLen: 32 });\n}\n\nexport function sha256(message: ByteInput): Uint8Array {\n  return _sha256(ensureBytes(message));\n}\n","import { isEmpty } from \"@fleet-sdk/common\";\n\n/**\n * EC point type\n */\nenum EcPointType {\n  /**\n   * Compressed, positive Y coordinate\n   */\n  Compressed = 0x02,\n  /**\n   * Compressed, negative Y coordinate\n   */\n  CompressedOdd = 0x03,\n  /**\n   * Uncompressed\n   */\n  Uncompressed = 0x04\n}\n\n/**\n * Validate Elliptic Curve point\n *\n * @param pointBytes EC point bytes\n * @returns True if the point is valid\n */\nexport function validateEcPoint(pointBytes: Uint8Array) {\n  if (isEmpty(pointBytes)) return false;\n\n  switch (pointBytes[0]) {\n    case EcPointType.Compressed:\n    case EcPointType.CompressedOdd:\n      return pointBytes.length === 33;\n    case EcPointType.Uncompressed:\n      return pointBytes.length === 65;\n    default:\n      return false;\n  }\n}\n","import { randomBytes as nobleRandomBytes } from \"@noble/hashes/utils\";\n\n/**\n * Secure PRNG from \"@noble/hashes\". Uses crypto.getRandomValues, which defers to OS.\n */\nexport const randomBytes = nobleRandomBytes as (bytesLength?: number) => Uint8Array;\n\nexport * from \"./hashes\";\nexport * from \"./types\";\nexport * from \"./coders\";\nexport * from \"./ecpoint\";\n"]}